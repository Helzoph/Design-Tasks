---
name: task-ticket-writer
description: 创建项目代码修改方案的 Skill。基于设计文档和需求，在 docs/tasks 目录下创建详细的修改方案工单，包含目的、背景、代码变更和设计关联。
---

# Task Ticket Writer

## 概述

这个 Skill 专门负责创建项目代码修改方案。它会在 docs/tasks 目录下创建一个详细的修改方案（即"工单"），将设计蓝图转化为可执行的代码变更指南。这是连接"蓝图"和"代码实现"的桥梁。

## 使用场景

当用户使用 `/dt` 或 `/dt-tasks` 命令时，这个 Skill 会在第四阶段被调用，用于：
1. 基于设计文档创建详细的修改方案
2. 生成递增的任务 ID
3. 详细描述修改目的、背景和代码变更
4. 建立设计与实现的关联关系

## 模板使用

这个 Skill 使用统一的任务工单模板：`universal_task_template.md`

模板结构：
```markdown
# <id>-<type>-<task_description>
## 修改目的与背景
## 任务元信息
  - 优先级
  - 预估执行时间(格式：小时(天数))
  - 任务依赖关系
  - 执行顺序
## 涉及的设计文档
## 修改方案
## 测试策略
  - 单元测试
  - 集成测试
## 参考资料
```

## 工作流程

### 第 1 步：获取任务 ID

执行脚本获取下一个任务 ID：
```bash
Bash: python scripts/get_next_task_id.py [tasks_dir]
```

参数说明：
- `tasks_dir`（可选）：任务文件目录路径，默认为 `docs/tasks`

该脚本会：
- 扫描指定目录下的所有任务文件
- 解析所有现有任务文件的 ID
- 返回下一个递增的 ID（格式：001, 002, 003...）

### 第 2 步：读取模板

读取任务工单模板：
```bash
Read: assets/universal_task_template.md
```

### 第 3 步：创建任务工单

基于需求和设计文档创建任务工单：

1. **生成 YAML Frontmatter**：
   - 在文件顶部添加 YAML 格式的元数据头
   - 包含字段：`id`、`type`、`description`、`status`、`created_at`、`linked_design`
   - `status` 初始值设为 `todo`，后续流转：`todo` → `in_progress` → `completed` → `verified`
   - `linked_design`：关联的设计文档路径数组

2. **创建任务标题**：
   - 格式：`<id>-<type>-<task_description>`
   - 示例：`003-feat-design-order-model`

3. **添加执行者必读（熔断机制）**：
   - 在正文开头添加 `## 执行者必读 (Circuit Breaker)` 章节
   - **单向依赖**：必须严格遵循 Design 文档
   - **熔断机制**：如果发现代码实现无法符合 Design 文档，或者 Design 文档逻辑有误，**立即停止**
   - 报错并建议用户运行 `/dt-design` 修正设计
   - 禁止擅自修改代码以绕过设计

4. **描述修改目的与背景**：
   - 详细说明为什么要做这次修改
   - 描述当前存在的问题
   - 解释新设计如何解决问题

5. **填写任务元信息**：
   - **优先级**：高/中/低
   - **预估执行时间**：以小时为单位，按8小时工作制计算天数，格式为 `16小时(2天)` 或 `4小时(0.5天)`
   - **任务依赖关系**：列出依赖的前置任务或被依赖的后续任务ID
   - **执行顺序**：说明与其他任务的执行先后关系

6. **核心依赖（Reading List）**：
   - 在 `## 核心依赖 (Reading List)` 章节下列出
   - **设计依据**：关联的核心逻辑设计文档
   - **架构规范**：代码风格和规范文档
   - **现有代码**：增量修改时需要参考的代码目录
   - **重要提示**：执行 Agent 在开始写代码前，必须调用 Read 工具读取这些文件

7. **描述修改方案**：
   - 按前端/后端分类
   - 每个修改点包含：文件路径、说明、关键代码变更
   - 展示新旧逻辑对比
   - **控制文档长度**：确保整个任务文档不超过 500 行，如果过长需提醒用户拆分任务
   - **代码块限制**：每个代码块不超过 10 行，建议只展示 1-3 行核心逻辑，避免给太多代码
   - **禁止大段代码**：不要在工单中粘贴大量代码片段，使用 Reading List 替代

8. **编写测试策略**：
   - **单元测试**：简要描述1-2个主要测试点
   - **集成测试**：简要描述1个端到端测试点
   - 注意控制内容长度，避免过多测试用例导致文档过长

9. **添加参考资料**：
   - 列出相关的GitHub仓库、文档链接等
   - 方便Agent使用context7 MCP查看相关文档

### 第 4 步：保存任务工单

将任务工单保存到 docs/tasks/ 目录：
- 文件名格式：`<id>-<type>-<task_description>.md`
- 例如：`001-feat-add_user_authentication.md`

## 任务工单规范

### YAML Frontmatter 规范

每个任务工单文件必须在顶部包含 YAML 格式的元数据头：

```yaml
---
id: "003"
type: "feat"
description: "design-order-model"
status: "todo"
created_at: "2025-11-20"
---
```

**字段说明**：
- **id**：任务唯一标识（001, 002, 003...）
- **type**：任务类型
  - `feat`：新功能
  - `fix`：修复问题
  - `refactor`：重构
  - `docs`：文档更新
  - `style`：样式调整
  - `test`：测试相关
- **description**：任务简短描述（英文，用下划线连接）
- **status**：任务状态，流转：`todo` → `in_progress` → `completed` → `verified`
- **created_at**：创建时间（ISO-8601 格式）
- **linked_design**：关联的设计文档路径数组

### 文件命名规范

```
<id>-<type>-<task_description>.md
```

示例：`001-feat-add_user_authentication.md`

### 内容要求

**执行者必读（熔断机制）**：
- 必须在正文开头包含此章节
- **单向依赖**：必须严格遵循 Design 文档
- **熔断机制**：如果发现代码实现无法符合 Design 文档，或者 Design 文档逻辑有误，**立即停止**
- 禁止擅自修改代码以绕过设计

**核心依赖（Reading List）**：
- 列出执行前必须阅读的文件
- 包含：设计依据、架构规范、现有代码
- 执行 Agent 必须调用 Read 工具读取这些文件

**代码展示**：
- **不要**写非常详细的代码
- 只展示关键代码片段
- **新旧逻辑对比**应该在这里展示
- **代码块限制**：每个代码块不超过 10 行，建议只展示 1-3 行核心逻辑
- **禁止大段代码**：使用 Reading List 替代粘贴大量代码

**长度限制**：
- 任务文档应控制在 **200-300 行**，最多不超过 **500 行**
- 如果任务内容过长，需要提醒用户将任务拆分为多个子任务
- 每个任务应专注于单一功能点或变更

**任务元信息**：
- **优先级**：明确标注高/中/低优先级
- **预估执行时间**：使用小时+天数的格式，如 `16小时(2天)`
- **依赖关系**：清晰列出任务间的依赖关系和执行顺序

**设计关联**：
- 在 YAML Frontmatter 中使用 `linked_design` 字段
- 在正文的"核心依赖"章节中详细说明

**测试策略**：
- 简要描述单元测试和集成测试
- 控制在1-2个测试点，避免过多内容
- 提供测试文件路径和测试场景

**参考资料**：
- 列出GitHub仓库、文档链接等外部资源
- 方便Agent使用context7 MCP工具查看

## 输出格式

返回任务工单创建信息：
- **任务 ID**：递增的任务序号
- **文件路径**：任务工单的完整路径
- **任务描述**：任务标题和简要描述
